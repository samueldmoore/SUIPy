To get started building a GUI with SimUI, a basic understanding of how to use the two high-level classes GUI and GUIData is in order. A configuration file is needed which tells the program how to lay out the GUI. It contains the layout and some necessary metadata for the program. This metadata is a dictionary of key strings necessary for the framework to interpret the config data. It Uses the keys specified by the values in this dict to retrieve information from the configuration which could potentially use user-defined keys for attributes like "type" or "children". Most users may use values for this dict as suggested by the hard-coded key-keys (keys to the keys in this dict) in the code. Some keys are used by the builders for specific widgets, and others are more general data access keys used by managing classes.

In the call to the GUIData class, this configuration file and the string keys to the two dictionaries it contains are passed. The keys passed to initialize GUIData must match the keys used in the configuration file for the GUI layout.

The GUI class requires a callback actions mapping. This must contain at least the entry "exit" for the top-level window, specifying the special value None as the callback:
{
    "exit": None
}

Every element is represented by a Python dictionary, with certain keys as specified in the user-provided keys dict, as follows:

    example_element = {"type": "example_type",
                        "name": "example",
                        "children": []
                        "properties": {"example_text": "Some text", "size": "200x300", "font": "arial 12", "etc.": "..."}
                    }

Here, the four keys, "type", "name", "children", and "properties" would be in the keys dict at the keys "type_key", "name_key", "children_key", and "properties_key" respectively, and these would be in all element dictionaries in the configuration data.

The first two take string values. "children" takes a list, like [child1, child2, etc.]. "properties" takes a dictionary. No "children" or "properties" are required, so either or both of these may be empty (have empty list or dictionary values of [] or {}, respectively).

This package consists of a useful classes to make and manipulate a graphical user interface with minimal effort on the programmer's part.

The workhorse class under the hood is GUIFactory. A GUIFactory object can be used to make a GUI layout and associate functions with the actions of clicking the buttons and switches on the GUI. It makes the layout based on data that can either be hard-coded into a Python script, using Python dictionaries and lists, or be read in from a JSON file and loaded as Python dictionaries and lists using json.loads(). GUIFactory is not intended to be called directly by the user, but to be used via higher-level classes: GUI and GUIData.


The "properties" sub-dictionary is passed to the element builder and contains specifications about that particular element ("example," in this case). The keys recognized by the builder vary from type to type. For example, the ValueEntryBuilder recognizes "show_text" (takes a string) and "default_value" (takes a string or a number). Unrecognized "properties" keys are ignored.

"properties" dictionary keys and values by element type (best viewed with Courier or Monotext), where the value under "type" is the str value hardcoded in the GUIData and other classes to recognize widgets of that type (remember that "type" is only a suggested value for "type_key" in the user-supplied keys dict; you may want to refer to this attribute as "breed", "category", you name it -- all you need to do to use your custom key is put it in the slot of the keys dict that is keyed by the str "type_key"):

"type"           |Key                |Default value          |
=================|===================|=======================|
"text_box"       |"default_text"     |""                     |
-----------------|-------------------|-----------------------|
"text_box"       |"width"[characters]|40                     |
-----------------|-------------------|-----------------------|
"text_box"       |"height"[lines]    |5                      |
-----------------|-------------------|-----------------------|
"text_box"       |"has_scrollbar"    |False                  |
-----------------|-------------------|-----------------------|
"text_line"      |"visible_text"     |"Default text"         |
-----------------|-------------------|-----------------------|
"text_line"      |"justification"    |"left"                 |
-----------------|-------------------|-----------------------|
"entry"          |"default_value"    |"0"                    |
-----------------|-------------------|-----------------------|
"entry"          |"visible_text"     |"New Value Entry"      |
-----------------|-------------------|-----------------------|
"entry"          |"width"            |15                     |
-----------------|-------------------|-----------------------|
"drop_down"      |"options"          |"Default_Option"       |
-----------------|-------------------|-----------------------|
"drop_down"      |"default_option"   |None                   |
-----------------|-------------------|-----------------------|
"drop_down"      |"only_selectable"  |True                   |
-----------------|-------------------|-----------------------|
"drop_down"      |"action"           |None                   |
-----------------|-------------------|-----------------------|
"button"         |"visible_text"     |"Default Button Text"  |
-----------------|-------------------|-----------------------|
"button"         |"action"           |"print"                |
-----------------|-------------------|-----------------------|
"drop_down_menu" |"visible_text"     |"Menu"                 |
-----------------|-------------------|-----------------------|
"menu_command"   |"visible_text"     |"Default Command Label"|
-----------------|-------------------|-----------------------|
"menu_command"   |"action"           |"print"                |
-----------------|-------------------|-----------------------|
"text_line"      |"visible_text"     |"Default text"         |
-----------------|-------------------|-----------------------|
"text_line"      |"visible"          |True                   |
-----------------|-------------------|-----------------------|
"window"         |"visible_text"     |"Default Window Title" |
-----------------|-------------------|-----------------------|
"window"         |"size_and_position"|"1040x640+0+0"         |
-----------------|-------------------|-----------------------|
"window"         |"action"           |"exit"                 |
-----------------|-------------------|-----------------------|
"frame"          |"visible_text"     |None                   |
-----------------|-------------------|-----------------------|
"frame"          |"height"           |20                     |
-----------------|-------------------|-----------------------|
"frame"          |"width"            |50                     |
-----------------|-------------------|-----------------------|
"tab"            |"visible_text"     |"Default Tab Label"    |
-----------------|-------------------|-----------------------|
[all types]      |"on_new_row"       |False                  |
-----------------|-------------------|-----------------------|
[all types]      |"column"           |0 (if "on_new_row")    |
-----------------|-------------------|-----------------------|

All the elements, except tabs, may take two additional properties that specify their position on the layout: "on_new_row", and "column". The first is just a True/False boolean value controlling whether a new grid row is started for this element. Set this to True for the first row in a layout if a window-level menu bar is specified. It defaults to False. The "column" value is a integer or string representing the number of the grid column in which the element is placed, starting from 0 on the left, counting right. If an particular column is empty, it is invisible. For example, if the first element in a layout is specified at column 1 rather than 0, and no other elements are placed in column 0, all the elements in column 1 would appear to be all the way to the left, as if they were in column 0, because column 0 is empty (invisible).

None of the properties, even the last two, are necessary. The layout will generate without any properties, just using the defaults for each type of element (which are probably not exactly what you want). These are specified in the Builder.__call__() method for each element.

Some elements, like "type" values "entry", "drop_down", and "button", do not take "children", so the corrosponding list should always be empty, like so: [].

Other elements, like "frame", "tab_binder", can contain "children" that are placed inside them.

The "tab_binder" and "tab" elements are special. A "tab_binder" is designed to only take "tab" children. So please do not try giving a "tab_binder" any other types of children, like "entry" or "drop_down". First make a "tab", and pass any other types as children to the tab. A "tab" is designed to only have a "tab_binder" as a parent. So trying put a "tab" as a child for any type of widget other than a "tab_binder" will throw an error. 

The idea here is that to build a GUI, no coding is necessary. Just plug in the desired elements with their properties as data, and then organize them by putting the predefined child elements that you want to contain in parent elements into the "children" lists of their parents.